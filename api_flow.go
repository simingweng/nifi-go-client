/*
 * NiFi Rest Api
 *
 * The Rest Api provides programmatic access to command and control a NiFi instance in real time. Start and                                              stop processors, monitor queues, query provenance data, and more. Each endpoint below includes a description,                                             definitions of the expected input and output, potential response codes, and the authorizations required                                             to invoke each service.
 *
 * API version: 1.13.2
 * Contact: dev@nifi.apache.org
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package nifi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// FlowApiService FlowApi service
type FlowApiService service

type FlowApiApiActivateControllerServicesRequest struct {
	ctx        _context.Context
	ApiService *FlowApiService
	id         string
	body       *ActivateControllerServicesEntity
}

func (r FlowApiApiActivateControllerServicesRequest) Body(body ActivateControllerServicesEntity) FlowApiApiActivateControllerServicesRequest {
	r.body = &body
	return r
}

func (r FlowApiApiActivateControllerServicesRequest) Execute() (ActivateControllerServicesEntity, *_nethttp.Response, error) {
	return r.ApiService.ActivateControllerServicesExecute(r)
}

/*
 * ActivateControllerServices Enable or disable Controller Services in the specified Process Group.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The process group id.
 * @return FlowApiApiActivateControllerServicesRequest
 */
func (a *FlowApiService) ActivateControllerServices(ctx _context.Context, id string) FlowApiApiActivateControllerServicesRequest {
	return FlowApiApiActivateControllerServicesRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 * @return ActivateControllerServicesEntity
 */
func (a *FlowApiService) ActivateControllerServicesExecute(r FlowApiApiActivateControllerServicesRequest) (ActivateControllerServicesEntity, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ActivateControllerServicesEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowApiService.ActivateControllerServices")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/process-groups/{id}/controller-services"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowApiApiGenerateClientIdRequest struct {
	ctx        _context.Context
	ApiService *FlowApiService
}

func (r FlowApiApiGenerateClientIdRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.GenerateClientIdExecute(r)
}

/*
 * GenerateClientId Generates a client id.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return FlowApiApiGenerateClientIdRequest
 */
func (a *FlowApiService) GenerateClientId(ctx _context.Context) FlowApiApiGenerateClientIdRequest {
	return FlowApiApiGenerateClientIdRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return string
 */
func (a *FlowApiService) GenerateClientIdExecute(r FlowApiApiGenerateClientIdRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowApiService.GenerateClientId")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/client-id"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowApiApiGetAboutInfoRequest struct {
	ctx        _context.Context
	ApiService *FlowApiService
}

func (r FlowApiApiGetAboutInfoRequest) Execute() (AboutEntity, *_nethttp.Response, error) {
	return r.ApiService.GetAboutInfoExecute(r)
}

/*
 * GetAboutInfo Retrieves details about this NiFi to put in the About dialog
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return FlowApiApiGetAboutInfoRequest
 */
func (a *FlowApiService) GetAboutInfo(ctx _context.Context) FlowApiApiGetAboutInfoRequest {
	return FlowApiApiGetAboutInfoRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return AboutEntity
 */
func (a *FlowApiService) GetAboutInfoExecute(r FlowApiApiGetAboutInfoRequest) (AboutEntity, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AboutEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowApiService.GetAboutInfo")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/about"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowApiApiGetActionRequest struct {
	ctx        _context.Context
	ApiService *FlowApiService
	id         string
}

func (r FlowApiApiGetActionRequest) Execute() (ActionEntity, *_nethttp.Response, error) {
	return r.ApiService.GetActionExecute(r)
}

/*
 * GetAction Gets an action
 * Note: This endpoint is subject to change as NiFi and it's REST API evolve.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The action id.
 * @return FlowApiApiGetActionRequest
 */
func (a *FlowApiService) GetAction(ctx _context.Context, id string) FlowApiApiGetActionRequest {
	return FlowApiApiGetActionRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 * @return ActionEntity
 */
func (a *FlowApiService) GetActionExecute(r FlowApiApiGetActionRequest) (ActionEntity, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ActionEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowApiService.GetAction")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/history/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowApiApiGetBannersRequest struct {
	ctx        _context.Context
	ApiService *FlowApiService
}

func (r FlowApiApiGetBannersRequest) Execute() (BannerEntity, *_nethttp.Response, error) {
	return r.ApiService.GetBannersExecute(r)
}

/*
 * GetBanners Retrieves the banners for this NiFi
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return FlowApiApiGetBannersRequest
 */
func (a *FlowApiService) GetBanners(ctx _context.Context) FlowApiApiGetBannersRequest {
	return FlowApiApiGetBannersRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return BannerEntity
 */
func (a *FlowApiService) GetBannersExecute(r FlowApiApiGetBannersRequest) (BannerEntity, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BannerEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowApiService.GetBanners")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/banners"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowApiApiGetBucketsRequest struct {
	ctx        _context.Context
	ApiService *FlowApiService
	id         string
}

func (r FlowApiApiGetBucketsRequest) Execute() (BucketsEntity, *_nethttp.Response, error) {
	return r.ApiService.GetBucketsExecute(r)
}

/*
 * GetBuckets Gets the buckets from the specified registry for the current user
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The registry id.
 * @return FlowApiApiGetBucketsRequest
 */
func (a *FlowApiService) GetBuckets(ctx _context.Context, id string) FlowApiApiGetBucketsRequest {
	return FlowApiApiGetBucketsRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 * @return BucketsEntity
 */
func (a *FlowApiService) GetBucketsExecute(r FlowApiApiGetBucketsRequest) (BucketsEntity, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BucketsEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowApiService.GetBuckets")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/registries/{id}/buckets"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowApiApiGetBulletinBoardRequest struct {
	ctx        _context.Context
	ApiService *FlowApiService
	after      *string
	sourceName *string
	message    *string
	sourceId   *string
	groupId    *string
	limit      *string
}

func (r FlowApiApiGetBulletinBoardRequest) After(after string) FlowApiApiGetBulletinBoardRequest {
	r.after = &after
	return r
}
func (r FlowApiApiGetBulletinBoardRequest) SourceName(sourceName string) FlowApiApiGetBulletinBoardRequest {
	r.sourceName = &sourceName
	return r
}
func (r FlowApiApiGetBulletinBoardRequest) Message(message string) FlowApiApiGetBulletinBoardRequest {
	r.message = &message
	return r
}
func (r FlowApiApiGetBulletinBoardRequest) SourceId(sourceId string) FlowApiApiGetBulletinBoardRequest {
	r.sourceId = &sourceId
	return r
}
func (r FlowApiApiGetBulletinBoardRequest) GroupId(groupId string) FlowApiApiGetBulletinBoardRequest {
	r.groupId = &groupId
	return r
}
func (r FlowApiApiGetBulletinBoardRequest) Limit(limit string) FlowApiApiGetBulletinBoardRequest {
	r.limit = &limit
	return r
}

func (r FlowApiApiGetBulletinBoardRequest) Execute() (BulletinBoardEntity, *_nethttp.Response, error) {
	return r.ApiService.GetBulletinBoardExecute(r)
}

/*
 * GetBulletinBoard Gets current bulletins
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return FlowApiApiGetBulletinBoardRequest
 */
func (a *FlowApiService) GetBulletinBoard(ctx _context.Context) FlowApiApiGetBulletinBoardRequest {
	return FlowApiApiGetBulletinBoardRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return BulletinBoardEntity
 */
func (a *FlowApiService) GetBulletinBoardExecute(r FlowApiApiGetBulletinBoardRequest) (BulletinBoardEntity, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BulletinBoardEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowApiService.GetBulletinBoard")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/bulletin-board"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.after != nil {
		localVarQueryParams.Add("after", parameterToString(*r.after, ""))
	}
	if r.sourceName != nil {
		localVarQueryParams.Add("sourceName", parameterToString(*r.sourceName, ""))
	}
	if r.message != nil {
		localVarQueryParams.Add("message", parameterToString(*r.message, ""))
	}
	if r.sourceId != nil {
		localVarQueryParams.Add("sourceId", parameterToString(*r.sourceId, ""))
	}
	if r.groupId != nil {
		localVarQueryParams.Add("groupId", parameterToString(*r.groupId, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowApiApiGetBulletinsRequest struct {
	ctx        _context.Context
	ApiService *FlowApiService
}

func (r FlowApiApiGetBulletinsRequest) Execute() (ControllerBulletinsEntity, *_nethttp.Response, error) {
	return r.ApiService.GetBulletinsExecute(r)
}

/*
 * GetBulletins Retrieves Controller level bulletins
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return FlowApiApiGetBulletinsRequest
 */
func (a *FlowApiService) GetBulletins(ctx _context.Context) FlowApiApiGetBulletinsRequest {
	return FlowApiApiGetBulletinsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return ControllerBulletinsEntity
 */
func (a *FlowApiService) GetBulletinsExecute(r FlowApiApiGetBulletinsRequest) (ControllerBulletinsEntity, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ControllerBulletinsEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowApiService.GetBulletins")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/controller/bulletins"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowApiApiGetClusterSummaryRequest struct {
	ctx        _context.Context
	ApiService *FlowApiService
}

func (r FlowApiApiGetClusterSummaryRequest) Execute() (ClusteSummaryEntity, *_nethttp.Response, error) {
	return r.ApiService.GetClusterSummaryExecute(r)
}

/*
 * GetClusterSummary The cluster summary for this NiFi
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return FlowApiApiGetClusterSummaryRequest
 */
func (a *FlowApiService) GetClusterSummary(ctx _context.Context) FlowApiApiGetClusterSummaryRequest {
	return FlowApiApiGetClusterSummaryRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return ClusteSummaryEntity
 */
func (a *FlowApiService) GetClusterSummaryExecute(r FlowApiApiGetClusterSummaryRequest) (ClusteSummaryEntity, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ClusteSummaryEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowApiService.GetClusterSummary")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/cluster/summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowApiApiGetComponentHistoryRequest struct {
	ctx         _context.Context
	ApiService  *FlowApiService
	componentId string
}

func (r FlowApiApiGetComponentHistoryRequest) Execute() (ComponentHistoryEntity, *_nethttp.Response, error) {
	return r.ApiService.GetComponentHistoryExecute(r)
}

/*
 * GetComponentHistory Gets configuration history for a component
 * Note: This endpoint is subject to change as NiFi and it's REST API evolve.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param componentId The component id.
 * @return FlowApiApiGetComponentHistoryRequest
 */
func (a *FlowApiService) GetComponentHistory(ctx _context.Context, componentId string) FlowApiApiGetComponentHistoryRequest {
	return FlowApiApiGetComponentHistoryRequest{
		ApiService:  a,
		ctx:         ctx,
		componentId: componentId,
	}
}

/*
 * Execute executes the request
 * @return ComponentHistoryEntity
 */
func (a *FlowApiService) GetComponentHistoryExecute(r FlowApiApiGetComponentHistoryRequest) (ComponentHistoryEntity, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ComponentHistoryEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowApiService.GetComponentHistory")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/history/components/{componentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"componentId"+"}", _neturl.PathEscape(parameterToString(r.componentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowApiApiGetConnectionStatisticsRequest struct {
	ctx           _context.Context
	ApiService    *FlowApiService
	id            string
	nodewise      *bool
	clusterNodeId *string
}

func (r FlowApiApiGetConnectionStatisticsRequest) Nodewise(nodewise bool) FlowApiApiGetConnectionStatisticsRequest {
	r.nodewise = &nodewise
	return r
}
func (r FlowApiApiGetConnectionStatisticsRequest) ClusterNodeId(clusterNodeId string) FlowApiApiGetConnectionStatisticsRequest {
	r.clusterNodeId = &clusterNodeId
	return r
}

func (r FlowApiApiGetConnectionStatisticsRequest) Execute() (ConnectionStatisticsEntity, *_nethttp.Response, error) {
	return r.ApiService.GetConnectionStatisticsExecute(r)
}

/*
 * GetConnectionStatistics Gets statistics for a connection
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The connection id.
 * @return FlowApiApiGetConnectionStatisticsRequest
 */
func (a *FlowApiService) GetConnectionStatistics(ctx _context.Context, id string) FlowApiApiGetConnectionStatisticsRequest {
	return FlowApiApiGetConnectionStatisticsRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 * @return ConnectionStatisticsEntity
 */
func (a *FlowApiService) GetConnectionStatisticsExecute(r FlowApiApiGetConnectionStatisticsRequest) (ConnectionStatisticsEntity, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ConnectionStatisticsEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowApiService.GetConnectionStatistics")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/connections/{id}/statistics"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.nodewise != nil {
		localVarQueryParams.Add("nodewise", parameterToString(*r.nodewise, ""))
	}
	if r.clusterNodeId != nil {
		localVarQueryParams.Add("clusterNodeId", parameterToString(*r.clusterNodeId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowApiApiGetConnectionStatusRequest struct {
	ctx           _context.Context
	ApiService    *FlowApiService
	id            string
	nodewise      *bool
	clusterNodeId *string
}

func (r FlowApiApiGetConnectionStatusRequest) Nodewise(nodewise bool) FlowApiApiGetConnectionStatusRequest {
	r.nodewise = &nodewise
	return r
}
func (r FlowApiApiGetConnectionStatusRequest) ClusterNodeId(clusterNodeId string) FlowApiApiGetConnectionStatusRequest {
	r.clusterNodeId = &clusterNodeId
	return r
}

func (r FlowApiApiGetConnectionStatusRequest) Execute() (ConnectionStatusEntity, *_nethttp.Response, error) {
	return r.ApiService.GetConnectionStatusExecute(r)
}

/*
 * GetConnectionStatus Gets status for a connection
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The connection id.
 * @return FlowApiApiGetConnectionStatusRequest
 */
func (a *FlowApiService) GetConnectionStatus(ctx _context.Context, id string) FlowApiApiGetConnectionStatusRequest {
	return FlowApiApiGetConnectionStatusRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 * @return ConnectionStatusEntity
 */
func (a *FlowApiService) GetConnectionStatusExecute(r FlowApiApiGetConnectionStatusRequest) (ConnectionStatusEntity, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ConnectionStatusEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowApiService.GetConnectionStatus")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/connections/{id}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.nodewise != nil {
		localVarQueryParams.Add("nodewise", parameterToString(*r.nodewise, ""))
	}
	if r.clusterNodeId != nil {
		localVarQueryParams.Add("clusterNodeId", parameterToString(*r.clusterNodeId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowApiApiGetConnectionStatusHistoryRequest struct {
	ctx        _context.Context
	ApiService *FlowApiService
	id         string
}

func (r FlowApiApiGetConnectionStatusHistoryRequest) Execute() (StatusHistoryEntity, *_nethttp.Response, error) {
	return r.ApiService.GetConnectionStatusHistoryExecute(r)
}

/*
 * GetConnectionStatusHistory Gets the status history for a connection
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The connection id.
 * @return FlowApiApiGetConnectionStatusHistoryRequest
 */
func (a *FlowApiService) GetConnectionStatusHistory(ctx _context.Context, id string) FlowApiApiGetConnectionStatusHistoryRequest {
	return FlowApiApiGetConnectionStatusHistoryRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 * @return StatusHistoryEntity
 */
func (a *FlowApiService) GetConnectionStatusHistoryExecute(r FlowApiApiGetConnectionStatusHistoryRequest) (StatusHistoryEntity, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  StatusHistoryEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowApiService.GetConnectionStatusHistory")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/connections/{id}/status/history"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowApiApiGetControllerServiceTypesRequest struct {
	ctx                   _context.Context
	ApiService            *FlowApiService
	serviceType           *string
	serviceBundleGroup    *string
	serviceBundleArtifact *string
	serviceBundleVersion  *string
	bundleGroupFilter     *string
	bundleArtifactFilter  *string
	typeFilter            *string
}

func (r FlowApiApiGetControllerServiceTypesRequest) ServiceType(serviceType string) FlowApiApiGetControllerServiceTypesRequest {
	r.serviceType = &serviceType
	return r
}
func (r FlowApiApiGetControllerServiceTypesRequest) ServiceBundleGroup(serviceBundleGroup string) FlowApiApiGetControllerServiceTypesRequest {
	r.serviceBundleGroup = &serviceBundleGroup
	return r
}
func (r FlowApiApiGetControllerServiceTypesRequest) ServiceBundleArtifact(serviceBundleArtifact string) FlowApiApiGetControllerServiceTypesRequest {
	r.serviceBundleArtifact = &serviceBundleArtifact
	return r
}
func (r FlowApiApiGetControllerServiceTypesRequest) ServiceBundleVersion(serviceBundleVersion string) FlowApiApiGetControllerServiceTypesRequest {
	r.serviceBundleVersion = &serviceBundleVersion
	return r
}
func (r FlowApiApiGetControllerServiceTypesRequest) BundleGroupFilter(bundleGroupFilter string) FlowApiApiGetControllerServiceTypesRequest {
	r.bundleGroupFilter = &bundleGroupFilter
	return r
}
func (r FlowApiApiGetControllerServiceTypesRequest) BundleArtifactFilter(bundleArtifactFilter string) FlowApiApiGetControllerServiceTypesRequest {
	r.bundleArtifactFilter = &bundleArtifactFilter
	return r
}
func (r FlowApiApiGetControllerServiceTypesRequest) TypeFilter(typeFilter string) FlowApiApiGetControllerServiceTypesRequest {
	r.typeFilter = &typeFilter
	return r
}

func (r FlowApiApiGetControllerServiceTypesRequest) Execute() (ControllerServiceTypesEntity, *_nethttp.Response, error) {
	return r.ApiService.GetControllerServiceTypesExecute(r)
}

/*
 * GetControllerServiceTypes Retrieves the types of controller services that this NiFi supports
 * Note: This endpoint is subject to change as NiFi and it's REST API evolve.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return FlowApiApiGetControllerServiceTypesRequest
 */
func (a *FlowApiService) GetControllerServiceTypes(ctx _context.Context) FlowApiApiGetControllerServiceTypesRequest {
	return FlowApiApiGetControllerServiceTypesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return ControllerServiceTypesEntity
 */
func (a *FlowApiService) GetControllerServiceTypesExecute(r FlowApiApiGetControllerServiceTypesRequest) (ControllerServiceTypesEntity, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ControllerServiceTypesEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowApiService.GetControllerServiceTypes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/controller-service-types"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.serviceType != nil {
		localVarQueryParams.Add("serviceType", parameterToString(*r.serviceType, ""))
	}
	if r.serviceBundleGroup != nil {
		localVarQueryParams.Add("serviceBundleGroup", parameterToString(*r.serviceBundleGroup, ""))
	}
	if r.serviceBundleArtifact != nil {
		localVarQueryParams.Add("serviceBundleArtifact", parameterToString(*r.serviceBundleArtifact, ""))
	}
	if r.serviceBundleVersion != nil {
		localVarQueryParams.Add("serviceBundleVersion", parameterToString(*r.serviceBundleVersion, ""))
	}
	if r.bundleGroupFilter != nil {
		localVarQueryParams.Add("bundleGroupFilter", parameterToString(*r.bundleGroupFilter, ""))
	}
	if r.bundleArtifactFilter != nil {
		localVarQueryParams.Add("bundleArtifactFilter", parameterToString(*r.bundleArtifactFilter, ""))
	}
	if r.typeFilter != nil {
		localVarQueryParams.Add("typeFilter", parameterToString(*r.typeFilter, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowApiApiGetControllerServicesFromControllerRequest struct {
	ctx        _context.Context
	ApiService *FlowApiService
}

func (r FlowApiApiGetControllerServicesFromControllerRequest) Execute() (ControllerServicesEntity, *_nethttp.Response, error) {
	return r.ApiService.GetControllerServicesFromControllerExecute(r)
}

/*
 * GetControllerServicesFromController Gets controller services for reporting tasks
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return FlowApiApiGetControllerServicesFromControllerRequest
 */
func (a *FlowApiService) GetControllerServicesFromController(ctx _context.Context) FlowApiApiGetControllerServicesFromControllerRequest {
	return FlowApiApiGetControllerServicesFromControllerRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return ControllerServicesEntity
 */
func (a *FlowApiService) GetControllerServicesFromControllerExecute(r FlowApiApiGetControllerServicesFromControllerRequest) (ControllerServicesEntity, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ControllerServicesEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowApiService.GetControllerServicesFromController")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/controller/controller-services"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowApiApiGetControllerServicesFromGroupRequest struct {
	ctx                     _context.Context
	ApiService              *FlowApiService
	id                      string
	includeAncestorGroups   *bool
	includeDescendantGroups *bool
}

func (r FlowApiApiGetControllerServicesFromGroupRequest) IncludeAncestorGroups(includeAncestorGroups bool) FlowApiApiGetControllerServicesFromGroupRequest {
	r.includeAncestorGroups = &includeAncestorGroups
	return r
}
func (r FlowApiApiGetControllerServicesFromGroupRequest) IncludeDescendantGroups(includeDescendantGroups bool) FlowApiApiGetControllerServicesFromGroupRequest {
	r.includeDescendantGroups = &includeDescendantGroups
	return r
}

func (r FlowApiApiGetControllerServicesFromGroupRequest) Execute() (ControllerServicesEntity, *_nethttp.Response, error) {
	return r.ApiService.GetControllerServicesFromGroupExecute(r)
}

/*
 * GetControllerServicesFromGroup Gets all controller services
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The process group id.
 * @return FlowApiApiGetControllerServicesFromGroupRequest
 */
func (a *FlowApiService) GetControllerServicesFromGroup(ctx _context.Context, id string) FlowApiApiGetControllerServicesFromGroupRequest {
	return FlowApiApiGetControllerServicesFromGroupRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 * @return ControllerServicesEntity
 */
func (a *FlowApiService) GetControllerServicesFromGroupExecute(r FlowApiApiGetControllerServicesFromGroupRequest) (ControllerServicesEntity, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ControllerServicesEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowApiService.GetControllerServicesFromGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/process-groups/{id}/controller-services"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.includeAncestorGroups != nil {
		localVarQueryParams.Add("includeAncestorGroups", parameterToString(*r.includeAncestorGroups, ""))
	}
	if r.includeDescendantGroups != nil {
		localVarQueryParams.Add("includeDescendantGroups", parameterToString(*r.includeDescendantGroups, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowApiApiGetControllerStatusRequest struct {
	ctx        _context.Context
	ApiService *FlowApiService
}

func (r FlowApiApiGetControllerStatusRequest) Execute() (ControllerStatusEntity, *_nethttp.Response, error) {
	return r.ApiService.GetControllerStatusExecute(r)
}

/*
 * GetControllerStatus Gets the current status of this NiFi
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return FlowApiApiGetControllerStatusRequest
 */
func (a *FlowApiService) GetControllerStatus(ctx _context.Context) FlowApiApiGetControllerStatusRequest {
	return FlowApiApiGetControllerStatusRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return ControllerStatusEntity
 */
func (a *FlowApiService) GetControllerStatusExecute(r FlowApiApiGetControllerStatusRequest) (ControllerStatusEntity, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ControllerStatusEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowApiService.GetControllerStatus")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowApiApiGetCurrentUserRequest struct {
	ctx        _context.Context
	ApiService *FlowApiService
}

func (r FlowApiApiGetCurrentUserRequest) Execute() (CurrentUserEntity, *_nethttp.Response, error) {
	return r.ApiService.GetCurrentUserExecute(r)
}

/*
 * GetCurrentUser Retrieves the user identity of the user making the request
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return FlowApiApiGetCurrentUserRequest
 */
func (a *FlowApiService) GetCurrentUser(ctx _context.Context) FlowApiApiGetCurrentUserRequest {
	return FlowApiApiGetCurrentUserRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return CurrentUserEntity
 */
func (a *FlowApiService) GetCurrentUserExecute(r FlowApiApiGetCurrentUserRequest) (CurrentUserEntity, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CurrentUserEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowApiService.GetCurrentUser")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/current-user"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowApiApiGetFlowRequest struct {
	ctx        _context.Context
	ApiService *FlowApiService
	id         string
}

func (r FlowApiApiGetFlowRequest) Execute() (ProcessGroupFlowEntity, *_nethttp.Response, error) {
	return r.ApiService.GetFlowExecute(r)
}

/*
 * GetFlow Gets a process group
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The process group id.
 * @return FlowApiApiGetFlowRequest
 */
func (a *FlowApiService) GetFlow(ctx _context.Context, id string) FlowApiApiGetFlowRequest {
	return FlowApiApiGetFlowRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 * @return ProcessGroupFlowEntity
 */
func (a *FlowApiService) GetFlowExecute(r FlowApiApiGetFlowRequest) (ProcessGroupFlowEntity, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ProcessGroupFlowEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowApiService.GetFlow")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/process-groups/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowApiApiGetFlowConfigRequest struct {
	ctx        _context.Context
	ApiService *FlowApiService
}

func (r FlowApiApiGetFlowConfigRequest) Execute() (FlowConfigurationEntity, *_nethttp.Response, error) {
	return r.ApiService.GetFlowConfigExecute(r)
}

/*
 * GetFlowConfig Retrieves the configuration for this NiFi flow
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return FlowApiApiGetFlowConfigRequest
 */
func (a *FlowApiService) GetFlowConfig(ctx _context.Context) FlowApiApiGetFlowConfigRequest {
	return FlowApiApiGetFlowConfigRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return FlowConfigurationEntity
 */
func (a *FlowApiService) GetFlowConfigExecute(r FlowApiApiGetFlowConfigRequest) (FlowConfigurationEntity, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  FlowConfigurationEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowApiService.GetFlowConfig")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowApiApiGetFlowMetricsRequest struct {
	ctx        _context.Context
	ApiService *FlowApiService
	producer   string
}

func (r FlowApiApiGetFlowMetricsRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.GetFlowMetricsExecute(r)
}

/*
 * GetFlowMetrics Gets all metrics for the flow from a particular node
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param producer The producer for flow file metrics. Each producer may have its own output format.
 * @return FlowApiApiGetFlowMetricsRequest
 */
func (a *FlowApiService) GetFlowMetrics(ctx _context.Context, producer string) FlowApiApiGetFlowMetricsRequest {
	return FlowApiApiGetFlowMetricsRequest{
		ApiService: a,
		ctx:        ctx,
		producer:   producer,
	}
}

/*
 * Execute executes the request
 * @return map[string]interface{}
 */
func (a *FlowApiService) GetFlowMetricsExecute(r FlowApiApiGetFlowMetricsRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowApiService.GetFlowMetrics")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/metrics/{producer}"
	localVarPath = strings.Replace(localVarPath, "{"+"producer"+"}", _neturl.PathEscape(parameterToString(r.producer, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowApiApiGetFlowsRequest struct {
	ctx        _context.Context
	ApiService *FlowApiService
	registryId string
	bucketId   string
}

func (r FlowApiApiGetFlowsRequest) Execute() (VersionedFlowsEntity, *_nethttp.Response, error) {
	return r.ApiService.GetFlowsExecute(r)
}

/*
 * GetFlows Gets the flows from the specified registry and bucket for the current user
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param registryId The registry id.
 * @param bucketId The bucket id.
 * @return FlowApiApiGetFlowsRequest
 */
func (a *FlowApiService) GetFlows(ctx _context.Context, registryId string, bucketId string) FlowApiApiGetFlowsRequest {
	return FlowApiApiGetFlowsRequest{
		ApiService: a,
		ctx:        ctx,
		registryId: registryId,
		bucketId:   bucketId,
	}
}

/*
 * Execute executes the request
 * @return VersionedFlowsEntity
 */
func (a *FlowApiService) GetFlowsExecute(r FlowApiApiGetFlowsRequest) (VersionedFlowsEntity, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  VersionedFlowsEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowApiService.GetFlows")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/registries/{registry-id}/buckets/{bucket-id}/flows"
	localVarPath = strings.Replace(localVarPath, "{"+"registry-id"+"}", _neturl.PathEscape(parameterToString(r.registryId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"bucket-id"+"}", _neturl.PathEscape(parameterToString(r.bucketId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowApiApiGetInputPortStatusRequest struct {
	ctx           _context.Context
	ApiService    *FlowApiService
	id            string
	nodewise      *bool
	clusterNodeId *string
}

func (r FlowApiApiGetInputPortStatusRequest) Nodewise(nodewise bool) FlowApiApiGetInputPortStatusRequest {
	r.nodewise = &nodewise
	return r
}
func (r FlowApiApiGetInputPortStatusRequest) ClusterNodeId(clusterNodeId string) FlowApiApiGetInputPortStatusRequest {
	r.clusterNodeId = &clusterNodeId
	return r
}

func (r FlowApiApiGetInputPortStatusRequest) Execute() (PortStatusEntity, *_nethttp.Response, error) {
	return r.ApiService.GetInputPortStatusExecute(r)
}

/*
 * GetInputPortStatus Gets status for an input port
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The input port id.
 * @return FlowApiApiGetInputPortStatusRequest
 */
func (a *FlowApiService) GetInputPortStatus(ctx _context.Context, id string) FlowApiApiGetInputPortStatusRequest {
	return FlowApiApiGetInputPortStatusRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 * @return PortStatusEntity
 */
func (a *FlowApiService) GetInputPortStatusExecute(r FlowApiApiGetInputPortStatusRequest) (PortStatusEntity, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PortStatusEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowApiService.GetInputPortStatus")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/input-ports/{id}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.nodewise != nil {
		localVarQueryParams.Add("nodewise", parameterToString(*r.nodewise, ""))
	}
	if r.clusterNodeId != nil {
		localVarQueryParams.Add("clusterNodeId", parameterToString(*r.clusterNodeId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowApiApiGetOutputPortStatusRequest struct {
	ctx           _context.Context
	ApiService    *FlowApiService
	id            string
	nodewise      *bool
	clusterNodeId *string
}

func (r FlowApiApiGetOutputPortStatusRequest) Nodewise(nodewise bool) FlowApiApiGetOutputPortStatusRequest {
	r.nodewise = &nodewise
	return r
}
func (r FlowApiApiGetOutputPortStatusRequest) ClusterNodeId(clusterNodeId string) FlowApiApiGetOutputPortStatusRequest {
	r.clusterNodeId = &clusterNodeId
	return r
}

func (r FlowApiApiGetOutputPortStatusRequest) Execute() (PortStatusEntity, *_nethttp.Response, error) {
	return r.ApiService.GetOutputPortStatusExecute(r)
}

/*
 * GetOutputPortStatus Gets status for an output port
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The output port id.
 * @return FlowApiApiGetOutputPortStatusRequest
 */
func (a *FlowApiService) GetOutputPortStatus(ctx _context.Context, id string) FlowApiApiGetOutputPortStatusRequest {
	return FlowApiApiGetOutputPortStatusRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 * @return PortStatusEntity
 */
func (a *FlowApiService) GetOutputPortStatusExecute(r FlowApiApiGetOutputPortStatusRequest) (PortStatusEntity, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PortStatusEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowApiService.GetOutputPortStatus")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/output-ports/{id}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.nodewise != nil {
		localVarQueryParams.Add("nodewise", parameterToString(*r.nodewise, ""))
	}
	if r.clusterNodeId != nil {
		localVarQueryParams.Add("clusterNodeId", parameterToString(*r.clusterNodeId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowApiApiGetParameterContextsRequest struct {
	ctx        _context.Context
	ApiService *FlowApiService
}

func (r FlowApiApiGetParameterContextsRequest) Execute() (ParameterContextsEntity, *_nethttp.Response, error) {
	return r.ApiService.GetParameterContextsExecute(r)
}

/*
 * GetParameterContexts Gets all Parameter Contexts
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return FlowApiApiGetParameterContextsRequest
 */
func (a *FlowApiService) GetParameterContexts(ctx _context.Context) FlowApiApiGetParameterContextsRequest {
	return FlowApiApiGetParameterContextsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return ParameterContextsEntity
 */
func (a *FlowApiService) GetParameterContextsExecute(r FlowApiApiGetParameterContextsRequest) (ParameterContextsEntity, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ParameterContextsEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowApiService.GetParameterContexts")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/parameter-contexts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowApiApiGetPrioritizersRequest struct {
	ctx        _context.Context
	ApiService *FlowApiService
}

func (r FlowApiApiGetPrioritizersRequest) Execute() (PrioritizerTypesEntity, *_nethttp.Response, error) {
	return r.ApiService.GetPrioritizersExecute(r)
}

/*
 * GetPrioritizers Retrieves the types of prioritizers that this NiFi supports
 * Note: This endpoint is subject to change as NiFi and it's REST API evolve.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return FlowApiApiGetPrioritizersRequest
 */
func (a *FlowApiService) GetPrioritizers(ctx _context.Context) FlowApiApiGetPrioritizersRequest {
	return FlowApiApiGetPrioritizersRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return PrioritizerTypesEntity
 */
func (a *FlowApiService) GetPrioritizersExecute(r FlowApiApiGetPrioritizersRequest) (PrioritizerTypesEntity, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PrioritizerTypesEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowApiService.GetPrioritizers")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/prioritizers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowApiApiGetProcessGroupStatusRequest struct {
	ctx           _context.Context
	ApiService    *FlowApiService
	id            string
	recursive     *bool
	nodewise      *bool
	clusterNodeId *string
}

func (r FlowApiApiGetProcessGroupStatusRequest) Recursive(recursive bool) FlowApiApiGetProcessGroupStatusRequest {
	r.recursive = &recursive
	return r
}
func (r FlowApiApiGetProcessGroupStatusRequest) Nodewise(nodewise bool) FlowApiApiGetProcessGroupStatusRequest {
	r.nodewise = &nodewise
	return r
}
func (r FlowApiApiGetProcessGroupStatusRequest) ClusterNodeId(clusterNodeId string) FlowApiApiGetProcessGroupStatusRequest {
	r.clusterNodeId = &clusterNodeId
	return r
}

func (r FlowApiApiGetProcessGroupStatusRequest) Execute() (ProcessGroupStatusEntity, *_nethttp.Response, error) {
	return r.ApiService.GetProcessGroupStatusExecute(r)
}

/*
 * GetProcessGroupStatus Gets the status for a process group
 * The status for a process group includes status for all descendent components. When invoked on the root group with recursive set to true, it will return the current status of every component in the flow.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The process group id.
 * @return FlowApiApiGetProcessGroupStatusRequest
 */
func (a *FlowApiService) GetProcessGroupStatus(ctx _context.Context, id string) FlowApiApiGetProcessGroupStatusRequest {
	return FlowApiApiGetProcessGroupStatusRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 * @return ProcessGroupStatusEntity
 */
func (a *FlowApiService) GetProcessGroupStatusExecute(r FlowApiApiGetProcessGroupStatusRequest) (ProcessGroupStatusEntity, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ProcessGroupStatusEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowApiService.GetProcessGroupStatus")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/process-groups/{id}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.recursive != nil {
		localVarQueryParams.Add("recursive", parameterToString(*r.recursive, ""))
	}
	if r.nodewise != nil {
		localVarQueryParams.Add("nodewise", parameterToString(*r.nodewise, ""))
	}
	if r.clusterNodeId != nil {
		localVarQueryParams.Add("clusterNodeId", parameterToString(*r.clusterNodeId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowApiApiGetProcessGroupStatusHistoryRequest struct {
	ctx        _context.Context
	ApiService *FlowApiService
	id         string
}

func (r FlowApiApiGetProcessGroupStatusHistoryRequest) Execute() (StatusHistoryEntity, *_nethttp.Response, error) {
	return r.ApiService.GetProcessGroupStatusHistoryExecute(r)
}

/*
 * GetProcessGroupStatusHistory Gets status history for a remote process group
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The process group id.
 * @return FlowApiApiGetProcessGroupStatusHistoryRequest
 */
func (a *FlowApiService) GetProcessGroupStatusHistory(ctx _context.Context, id string) FlowApiApiGetProcessGroupStatusHistoryRequest {
	return FlowApiApiGetProcessGroupStatusHistoryRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 * @return StatusHistoryEntity
 */
func (a *FlowApiService) GetProcessGroupStatusHistoryExecute(r FlowApiApiGetProcessGroupStatusHistoryRequest) (StatusHistoryEntity, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  StatusHistoryEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowApiService.GetProcessGroupStatusHistory")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/process-groups/{id}/status/history"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowApiApiGetProcessorStatusRequest struct {
	ctx           _context.Context
	ApiService    *FlowApiService
	id            string
	nodewise      *bool
	clusterNodeId *string
}

func (r FlowApiApiGetProcessorStatusRequest) Nodewise(nodewise bool) FlowApiApiGetProcessorStatusRequest {
	r.nodewise = &nodewise
	return r
}
func (r FlowApiApiGetProcessorStatusRequest) ClusterNodeId(clusterNodeId string) FlowApiApiGetProcessorStatusRequest {
	r.clusterNodeId = &clusterNodeId
	return r
}

func (r FlowApiApiGetProcessorStatusRequest) Execute() (ProcessorStatusEntity, *_nethttp.Response, error) {
	return r.ApiService.GetProcessorStatusExecute(r)
}

/*
 * GetProcessorStatus Gets status for a processor
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The processor id.
 * @return FlowApiApiGetProcessorStatusRequest
 */
func (a *FlowApiService) GetProcessorStatus(ctx _context.Context, id string) FlowApiApiGetProcessorStatusRequest {
	return FlowApiApiGetProcessorStatusRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 * @return ProcessorStatusEntity
 */
func (a *FlowApiService) GetProcessorStatusExecute(r FlowApiApiGetProcessorStatusRequest) (ProcessorStatusEntity, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ProcessorStatusEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowApiService.GetProcessorStatus")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/processors/{id}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.nodewise != nil {
		localVarQueryParams.Add("nodewise", parameterToString(*r.nodewise, ""))
	}
	if r.clusterNodeId != nil {
		localVarQueryParams.Add("clusterNodeId", parameterToString(*r.clusterNodeId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowApiApiGetProcessorStatusHistoryRequest struct {
	ctx        _context.Context
	ApiService *FlowApiService
	id         string
}

func (r FlowApiApiGetProcessorStatusHistoryRequest) Execute() (StatusHistoryEntity, *_nethttp.Response, error) {
	return r.ApiService.GetProcessorStatusHistoryExecute(r)
}

/*
 * GetProcessorStatusHistory Gets status history for a processor
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The processor id.
 * @return FlowApiApiGetProcessorStatusHistoryRequest
 */
func (a *FlowApiService) GetProcessorStatusHistory(ctx _context.Context, id string) FlowApiApiGetProcessorStatusHistoryRequest {
	return FlowApiApiGetProcessorStatusHistoryRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 * @return StatusHistoryEntity
 */
func (a *FlowApiService) GetProcessorStatusHistoryExecute(r FlowApiApiGetProcessorStatusHistoryRequest) (StatusHistoryEntity, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  StatusHistoryEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowApiService.GetProcessorStatusHistory")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/processors/{id}/status/history"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowApiApiGetProcessorTypesRequest struct {
	ctx                  _context.Context
	ApiService           *FlowApiService
	bundleGroupFilter    *string
	bundleArtifactFilter *string
	type_                *string
}

func (r FlowApiApiGetProcessorTypesRequest) BundleGroupFilter(bundleGroupFilter string) FlowApiApiGetProcessorTypesRequest {
	r.bundleGroupFilter = &bundleGroupFilter
	return r
}
func (r FlowApiApiGetProcessorTypesRequest) BundleArtifactFilter(bundleArtifactFilter string) FlowApiApiGetProcessorTypesRequest {
	r.bundleArtifactFilter = &bundleArtifactFilter
	return r
}
func (r FlowApiApiGetProcessorTypesRequest) Type_(type_ string) FlowApiApiGetProcessorTypesRequest {
	r.type_ = &type_
	return r
}

func (r FlowApiApiGetProcessorTypesRequest) Execute() (ProcessorTypesEntity, *_nethttp.Response, error) {
	return r.ApiService.GetProcessorTypesExecute(r)
}

/*
 * GetProcessorTypes Retrieves the types of processors that this NiFi supports
 * Note: This endpoint is subject to change as NiFi and it's REST API evolve.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return FlowApiApiGetProcessorTypesRequest
 */
func (a *FlowApiService) GetProcessorTypes(ctx _context.Context) FlowApiApiGetProcessorTypesRequest {
	return FlowApiApiGetProcessorTypesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return ProcessorTypesEntity
 */
func (a *FlowApiService) GetProcessorTypesExecute(r FlowApiApiGetProcessorTypesRequest) (ProcessorTypesEntity, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ProcessorTypesEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowApiService.GetProcessorTypes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/processor-types"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.bundleGroupFilter != nil {
		localVarQueryParams.Add("bundleGroupFilter", parameterToString(*r.bundleGroupFilter, ""))
	}
	if r.bundleArtifactFilter != nil {
		localVarQueryParams.Add("bundleArtifactFilter", parameterToString(*r.bundleArtifactFilter, ""))
	}
	if r.type_ != nil {
		localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowApiApiGetRegistriesRequest struct {
	ctx        _context.Context
	ApiService *FlowApiService
}

func (r FlowApiApiGetRegistriesRequest) Execute() (RegistryClientsEntity, *_nethttp.Response, error) {
	return r.ApiService.GetRegistriesExecute(r)
}

/*
 * GetRegistries Gets the listing of available registries
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return FlowApiApiGetRegistriesRequest
 */
func (a *FlowApiService) GetRegistries(ctx _context.Context) FlowApiApiGetRegistriesRequest {
	return FlowApiApiGetRegistriesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return RegistryClientsEntity
 */
func (a *FlowApiService) GetRegistriesExecute(r FlowApiApiGetRegistriesRequest) (RegistryClientsEntity, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  RegistryClientsEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowApiService.GetRegistries")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/registries"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowApiApiGetRemoteProcessGroupStatusRequest struct {
	ctx           _context.Context
	ApiService    *FlowApiService
	id            string
	nodewise      *bool
	clusterNodeId *string
}

func (r FlowApiApiGetRemoteProcessGroupStatusRequest) Nodewise(nodewise bool) FlowApiApiGetRemoteProcessGroupStatusRequest {
	r.nodewise = &nodewise
	return r
}
func (r FlowApiApiGetRemoteProcessGroupStatusRequest) ClusterNodeId(clusterNodeId string) FlowApiApiGetRemoteProcessGroupStatusRequest {
	r.clusterNodeId = &clusterNodeId
	return r
}

func (r FlowApiApiGetRemoteProcessGroupStatusRequest) Execute() (RemoteProcessGroupStatusEntity, *_nethttp.Response, error) {
	return r.ApiService.GetRemoteProcessGroupStatusExecute(r)
}

/*
 * GetRemoteProcessGroupStatus Gets status for a remote process group
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The remote process group id.
 * @return FlowApiApiGetRemoteProcessGroupStatusRequest
 */
func (a *FlowApiService) GetRemoteProcessGroupStatus(ctx _context.Context, id string) FlowApiApiGetRemoteProcessGroupStatusRequest {
	return FlowApiApiGetRemoteProcessGroupStatusRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 * @return RemoteProcessGroupStatusEntity
 */
func (a *FlowApiService) GetRemoteProcessGroupStatusExecute(r FlowApiApiGetRemoteProcessGroupStatusRequest) (RemoteProcessGroupStatusEntity, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  RemoteProcessGroupStatusEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowApiService.GetRemoteProcessGroupStatus")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/remote-process-groups/{id}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.nodewise != nil {
		localVarQueryParams.Add("nodewise", parameterToString(*r.nodewise, ""))
	}
	if r.clusterNodeId != nil {
		localVarQueryParams.Add("clusterNodeId", parameterToString(*r.clusterNodeId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowApiApiGetRemoteProcessGroupStatusHistoryRequest struct {
	ctx        _context.Context
	ApiService *FlowApiService
	id         string
}

func (r FlowApiApiGetRemoteProcessGroupStatusHistoryRequest) Execute() (StatusHistoryEntity, *_nethttp.Response, error) {
	return r.ApiService.GetRemoteProcessGroupStatusHistoryExecute(r)
}

/*
 * GetRemoteProcessGroupStatusHistory Gets the status history
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The remote process group id.
 * @return FlowApiApiGetRemoteProcessGroupStatusHistoryRequest
 */
func (a *FlowApiService) GetRemoteProcessGroupStatusHistory(ctx _context.Context, id string) FlowApiApiGetRemoteProcessGroupStatusHistoryRequest {
	return FlowApiApiGetRemoteProcessGroupStatusHistoryRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 * @return StatusHistoryEntity
 */
func (a *FlowApiService) GetRemoteProcessGroupStatusHistoryExecute(r FlowApiApiGetRemoteProcessGroupStatusHistoryRequest) (StatusHistoryEntity, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  StatusHistoryEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowApiService.GetRemoteProcessGroupStatusHistory")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/remote-process-groups/{id}/status/history"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowApiApiGetReportingTaskTypesRequest struct {
	ctx                  _context.Context
	ApiService           *FlowApiService
	bundleGroupFilter    *string
	bundleArtifactFilter *string
	type_                *string
}

func (r FlowApiApiGetReportingTaskTypesRequest) BundleGroupFilter(bundleGroupFilter string) FlowApiApiGetReportingTaskTypesRequest {
	r.bundleGroupFilter = &bundleGroupFilter
	return r
}
func (r FlowApiApiGetReportingTaskTypesRequest) BundleArtifactFilter(bundleArtifactFilter string) FlowApiApiGetReportingTaskTypesRequest {
	r.bundleArtifactFilter = &bundleArtifactFilter
	return r
}
func (r FlowApiApiGetReportingTaskTypesRequest) Type_(type_ string) FlowApiApiGetReportingTaskTypesRequest {
	r.type_ = &type_
	return r
}

func (r FlowApiApiGetReportingTaskTypesRequest) Execute() (ReportingTaskTypesEntity, *_nethttp.Response, error) {
	return r.ApiService.GetReportingTaskTypesExecute(r)
}

/*
 * GetReportingTaskTypes Retrieves the types of reporting tasks that this NiFi supports
 * Note: This endpoint is subject to change as NiFi and it's REST API evolve.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return FlowApiApiGetReportingTaskTypesRequest
 */
func (a *FlowApiService) GetReportingTaskTypes(ctx _context.Context) FlowApiApiGetReportingTaskTypesRequest {
	return FlowApiApiGetReportingTaskTypesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return ReportingTaskTypesEntity
 */
func (a *FlowApiService) GetReportingTaskTypesExecute(r FlowApiApiGetReportingTaskTypesRequest) (ReportingTaskTypesEntity, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ReportingTaskTypesEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowApiService.GetReportingTaskTypes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/reporting-task-types"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.bundleGroupFilter != nil {
		localVarQueryParams.Add("bundleGroupFilter", parameterToString(*r.bundleGroupFilter, ""))
	}
	if r.bundleArtifactFilter != nil {
		localVarQueryParams.Add("bundleArtifactFilter", parameterToString(*r.bundleArtifactFilter, ""))
	}
	if r.type_ != nil {
		localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowApiApiGetReportingTasksRequest struct {
	ctx        _context.Context
	ApiService *FlowApiService
}

func (r FlowApiApiGetReportingTasksRequest) Execute() (ReportingTasksEntity, *_nethttp.Response, error) {
	return r.ApiService.GetReportingTasksExecute(r)
}

/*
 * GetReportingTasks Gets all reporting tasks
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return FlowApiApiGetReportingTasksRequest
 */
func (a *FlowApiService) GetReportingTasks(ctx _context.Context) FlowApiApiGetReportingTasksRequest {
	return FlowApiApiGetReportingTasksRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return ReportingTasksEntity
 */
func (a *FlowApiService) GetReportingTasksExecute(r FlowApiApiGetReportingTasksRequest) (ReportingTasksEntity, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ReportingTasksEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowApiService.GetReportingTasks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/reporting-tasks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowApiApiGetTemplatesRequest struct {
	ctx        _context.Context
	ApiService *FlowApiService
}

func (r FlowApiApiGetTemplatesRequest) Execute() (TemplatesEntity, *_nethttp.Response, error) {
	return r.ApiService.GetTemplatesExecute(r)
}

/*
 * GetTemplates Gets all templates
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return FlowApiApiGetTemplatesRequest
 */
func (a *FlowApiService) GetTemplates(ctx _context.Context) FlowApiApiGetTemplatesRequest {
	return FlowApiApiGetTemplatesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return TemplatesEntity
 */
func (a *FlowApiService) GetTemplatesExecute(r FlowApiApiGetTemplatesRequest) (TemplatesEntity, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  TemplatesEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowApiService.GetTemplates")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/templates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowApiApiGetVersionsRequest struct {
	ctx        _context.Context
	ApiService *FlowApiService
	registryId string
	bucketId   string
	flowId     string
}

func (r FlowApiApiGetVersionsRequest) Execute() (VersionedFlowSnapshotMetadataSetEntity, *_nethttp.Response, error) {
	return r.ApiService.GetVersionsExecute(r)
}

/*
 * GetVersions Gets the flow versions from the specified registry and bucket for the specified flow for the current user
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param registryId The registry id.
 * @param bucketId The bucket id.
 * @param flowId The flow id.
 * @return FlowApiApiGetVersionsRequest
 */
func (a *FlowApiService) GetVersions(ctx _context.Context, registryId string, bucketId string, flowId string) FlowApiApiGetVersionsRequest {
	return FlowApiApiGetVersionsRequest{
		ApiService: a,
		ctx:        ctx,
		registryId: registryId,
		bucketId:   bucketId,
		flowId:     flowId,
	}
}

/*
 * Execute executes the request
 * @return VersionedFlowSnapshotMetadataSetEntity
 */
func (a *FlowApiService) GetVersionsExecute(r FlowApiApiGetVersionsRequest) (VersionedFlowSnapshotMetadataSetEntity, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  VersionedFlowSnapshotMetadataSetEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowApiService.GetVersions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/registries/{registry-id}/buckets/{bucket-id}/flows/{flow-id}/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"registry-id"+"}", _neturl.PathEscape(parameterToString(r.registryId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"bucket-id"+"}", _neturl.PathEscape(parameterToString(r.bucketId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"flow-id"+"}", _neturl.PathEscape(parameterToString(r.flowId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowApiApiQueryHistoryRequest struct {
	ctx          _context.Context
	ApiService   *FlowApiService
	offset       *string
	count        *string
	sortColumn   *string
	sortOrder    *string
	startDate    *string
	endDate      *string
	userIdentity *string
	sourceId     *string
}

func (r FlowApiApiQueryHistoryRequest) Offset(offset string) FlowApiApiQueryHistoryRequest {
	r.offset = &offset
	return r
}
func (r FlowApiApiQueryHistoryRequest) Count(count string) FlowApiApiQueryHistoryRequest {
	r.count = &count
	return r
}
func (r FlowApiApiQueryHistoryRequest) SortColumn(sortColumn string) FlowApiApiQueryHistoryRequest {
	r.sortColumn = &sortColumn
	return r
}
func (r FlowApiApiQueryHistoryRequest) SortOrder(sortOrder string) FlowApiApiQueryHistoryRequest {
	r.sortOrder = &sortOrder
	return r
}
func (r FlowApiApiQueryHistoryRequest) StartDate(startDate string) FlowApiApiQueryHistoryRequest {
	r.startDate = &startDate
	return r
}
func (r FlowApiApiQueryHistoryRequest) EndDate(endDate string) FlowApiApiQueryHistoryRequest {
	r.endDate = &endDate
	return r
}
func (r FlowApiApiQueryHistoryRequest) UserIdentity(userIdentity string) FlowApiApiQueryHistoryRequest {
	r.userIdentity = &userIdentity
	return r
}
func (r FlowApiApiQueryHistoryRequest) SourceId(sourceId string) FlowApiApiQueryHistoryRequest {
	r.sourceId = &sourceId
	return r
}

func (r FlowApiApiQueryHistoryRequest) Execute() (HistoryEntity, *_nethttp.Response, error) {
	return r.ApiService.QueryHistoryExecute(r)
}

/*
 * QueryHistory Gets configuration history
 * Note: This endpoint is subject to change as NiFi and it's REST API evolve.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return FlowApiApiQueryHistoryRequest
 */
func (a *FlowApiService) QueryHistory(ctx _context.Context) FlowApiApiQueryHistoryRequest {
	return FlowApiApiQueryHistoryRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return HistoryEntity
 */
func (a *FlowApiService) QueryHistoryExecute(r FlowApiApiQueryHistoryRequest) (HistoryEntity, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  HistoryEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowApiService.QueryHistory")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.offset == nil {
		return localVarReturnValue, nil, reportError("offset is required and must be specified")
	}
	if r.count == nil {
		return localVarReturnValue, nil, reportError("count is required and must be specified")
	}

	localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	localVarQueryParams.Add("count", parameterToString(*r.count, ""))
	if r.sortColumn != nil {
		localVarQueryParams.Add("sortColumn", parameterToString(*r.sortColumn, ""))
	}
	if r.sortOrder != nil {
		localVarQueryParams.Add("sortOrder", parameterToString(*r.sortOrder, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.userIdentity != nil {
		localVarQueryParams.Add("userIdentity", parameterToString(*r.userIdentity, ""))
	}
	if r.sourceId != nil {
		localVarQueryParams.Add("sourceId", parameterToString(*r.sourceId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowApiApiScheduleComponentsRequest struct {
	ctx        _context.Context
	ApiService *FlowApiService
	id         string
	body       *ScheduleComponentsEntity
}

func (r FlowApiApiScheduleComponentsRequest) Body(body ScheduleComponentsEntity) FlowApiApiScheduleComponentsRequest {
	r.body = &body
	return r
}

func (r FlowApiApiScheduleComponentsRequest) Execute() (ScheduleComponentsEntity, *_nethttp.Response, error) {
	return r.ApiService.ScheduleComponentsExecute(r)
}

/*
 * ScheduleComponents Schedule or unschedule components in the specified Process Group.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The process group id.
 * @return FlowApiApiScheduleComponentsRequest
 */
func (a *FlowApiService) ScheduleComponents(ctx _context.Context, id string) FlowApiApiScheduleComponentsRequest {
	return FlowApiApiScheduleComponentsRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

/*
 * Execute executes the request
 * @return ScheduleComponentsEntity
 */
func (a *FlowApiService) ScheduleComponentsExecute(r FlowApiApiScheduleComponentsRequest) (ScheduleComponentsEntity, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ScheduleComponentsEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowApiService.ScheduleComponents")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/process-groups/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowApiApiSearchClusterRequest struct {
	ctx        _context.Context
	ApiService *FlowApiService
	q          *string
}

func (r FlowApiApiSearchClusterRequest) Q(q string) FlowApiApiSearchClusterRequest {
	r.q = &q
	return r
}

func (r FlowApiApiSearchClusterRequest) Execute() (ClusterSearchResultsEntity, *_nethttp.Response, error) {
	return r.ApiService.SearchClusterExecute(r)
}

/*
 * SearchCluster Searches the cluster for a node with the specified address
 * Note: This endpoint is subject to change as NiFi and it's REST API evolve.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return FlowApiApiSearchClusterRequest
 */
func (a *FlowApiService) SearchCluster(ctx _context.Context) FlowApiApiSearchClusterRequest {
	return FlowApiApiSearchClusterRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return ClusterSearchResultsEntity
 */
func (a *FlowApiService) SearchClusterExecute(r FlowApiApiSearchClusterRequest) (ClusterSearchResultsEntity, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ClusterSearchResultsEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowApiService.SearchCluster")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/cluster/search-results"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.q == nil {
		return localVarReturnValue, nil, reportError("q is required and must be specified")
	}

	localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type FlowApiApiSearchFlowRequest struct {
	ctx        _context.Context
	ApiService *FlowApiService
	q          *string
	a          *string
}

func (r FlowApiApiSearchFlowRequest) Q(q string) FlowApiApiSearchFlowRequest {
	r.q = &q
	return r
}
func (r FlowApiApiSearchFlowRequest) A(a string) FlowApiApiSearchFlowRequest {
	r.a = &a
	return r
}

func (r FlowApiApiSearchFlowRequest) Execute() (SearchResultsEntity, *_nethttp.Response, error) {
	return r.ApiService.SearchFlowExecute(r)
}

/*
 * SearchFlow Performs a search against this NiFi using the specified search term
 * Only search results from authorized components will be returned.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return FlowApiApiSearchFlowRequest
 */
func (a *FlowApiService) SearchFlow(ctx _context.Context) FlowApiApiSearchFlowRequest {
	return FlowApiApiSearchFlowRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return SearchResultsEntity
 */
func (a *FlowApiService) SearchFlowExecute(r FlowApiApiSearchFlowRequest) (SearchResultsEntity, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SearchResultsEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlowApiService.SearchFlow")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/flow/search-results"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.q != nil {
		localVarQueryParams.Add("q", parameterToString(*r.q, ""))
	}
	if r.a != nil {
		localVarQueryParams.Add("a", parameterToString(*r.a, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
